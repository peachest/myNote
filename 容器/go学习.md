# Go语言学习

[toc]
## Go程序组织
### 环境变量
GOROOT，Go语言的SDK路径

GOPATH，GO项目的工作区，可以是多个目录的路径集合，一个目录对应一个工作区。
这些工作区存放源码文件，install后的`.a`文件（即静态库文件），和`build`后产生的可执行文件。

GOBIN

### 包和导入

单行导入
``` go
import "fmt"
import "flag"
```

多行导入
``` go 
import (
    "fmt"
    "flag"
)
```

匿名导入。触发`init()`，将包编译到可执行文件，不调用包内任何东西。
``` go
import _ "/path/topackage"
```

导入全部程序实体。使用时不再需要使用`package.func()`进行限定调用，可以直接使用函数名进行调用。
``` go
import . "fmt"
```

所有import语句放到源文件的**开头部分**。
Go语言的import类似JS中es6语法的import语句，即
* 编译时**静态分析**就能得到文件的依赖关系，不需要运行时才能决定
* 导出与导入的是程序实体的引用，而非值的复制。即若两个文件同时导入同一个实体，则对其修改会同步

源码文件所在的目录，相对于src目录的相对路径，就是**代码包的导入路径**。
而使用`package.func()`进行限定调用时，必须使用声明时使用的package name而非目录名。

因此导入是不会发生冲突的，因为不同目录的包，导入路径本就不一样。但是若不同路径，包名相同的包，若同时导入，则在使用时可能发生冲突。
可以通过起别名的方式，格式为`import ( <alias> "/path/to/package" )`.


通常package name与目录名一致，但是这并非强制规定。允许包名与目录名不同，只需要**同目录下所有`go`文件都声明相同的package**即可
但是为了导入方便，避免引起使用上的问题，**总是应该让声明的包名与目录名一致**

### 特殊函数——main，init

程序入口（命令源代码）：main包内的main函数

特殊函数`init()`，先于main函数前执行（没有main也可以有init），执行一些初始化操作。执行顺序如下：
* init函数与其他初始化表达式按顺序执行。 
* **不同package**的init函数按导入顺序执行
* **相同package**的init函数，Go语言规范中没有说明，但是实践中按包内所有源文件名的字典序执行
* 同一go文件内的多个init函数，执行顺序是 **未定义的**，最好只定义一个init函数

init函数不可被主动调用。

### 导出程序实体

**程序实体：**变量、常量、函数、结构体、接口的统称。程序实体必须先声明，后使用。

**导出程序实体 ：**名称首字母大写的程序实体视作导出。即首字母大写为包级公开，首字母小写为包级私有。包级公开（导出）的程序实体，可以被其他包的代码调用


### 变量定义/重定义与作用域

声明语句，格式`var <变量名> <类型>`
```go
var a int
```

声明同时可以初始化，此时可以省略类型，因为根据初始化的值进行类型推断
支持批量声明并初始化
```go
var a = 10
var b, c = 20, 30
```

GO的作用域与C系语言的作用域一样，若内层声明了同名变量，则屏蔽外层同名变量。
GO语言引入**重声明**的语法糖。即对外层已经声明过的变量，在内层重新声明一个同名变量时可以使用`:=`并且省略关键字`var`
```go
var a = 10
{
    a := 20
}
```
该语法糖等价于
```go
var a = 10
{
    var a = 20
}
```

**同级作用域中不允许重复声明变量**。

:warning: 若使用`import . "package"`导入包内所有程序实体，若在文件级作用域定义了同名实体，则会报错`redeclared`。
因为导入的程序实体也是文件级作用域，同级作用域不允许重复定义。

## 类型基础
### 类型别名

类型别名，使用`type =。此时`char`与`uint8`是相同的类型
```go
type char = uint8
```

类型再定义，省略`=`.此时`char`与`uint8`是不同的类型
```go
type char uint8
```

### 判断变量类型

Go无法直接判断变量类型，但是可以判断接口类型。因此可以将变量强制转换为接口，再判断类型。

判断接口类型
```go
var value, ok = <interface>.(<type>)
```

将变量强制转换为空接口`interface{}`
```go
interface{}(<var>)
```

结合上述靓丽，则判断变量类型可写做：
```go
var value, ok = interfcae{}(<var>).(<type>)
```

### 如恩类型Rune

GO使用Rune类型处理中文，支持国际化。
`Rune`类型是`int32`类型的别名，处理Unicode点码。`Char`类型是`uint8`的别名。

utf-8的中文，1个字占3个字节。
截取指定数量字符的中英文混合字符串，使用rune类型非常方便
```go
var s = "Go语言编程"
var temp = []rune(s)            // [G, o, 语, 言, 编, 程]   将字符串强制转换为rune数组
var result = string(temp[:4])   // [G, o, 语, 言]    切片，再次转换回字符串类型         
```

### 值类型和引用类型

值类型：基础数据类型，数组类型，结构体类型

引用类型：函数，切片，字典，通道

函数传参时，值类型会拷贝一份，引用类型直接传递引用

### 数组和切片

二者本质区别：**数组长度固定，切片长度不固定**。

声明+`{}`列表初始化
```go
[3]int{1, 2, 3} // 数组

[ ]int{1, 2, 3} // 切片
```

使用`make()`创建切片
```go
make([]T, length[, capacity]) // 切片类型，长度，容量（可省略）
```

**切片底层是数组**


## 容器



















